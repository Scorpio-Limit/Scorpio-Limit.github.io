[{"id":"2e7944ca2e6ed341449d1a3cb4b30f5a","title":"SP30669题解","content":"\n题目链接\n\n题目大意有个人， 叫 Ada， 她在旅游， 在她那里， 共有 N 个城市， M 条路线。 一般情况下， 别人会去主城市和大城市游玩， 但是她不一般， Ada 想去离自己最远的地方玩， 因为她觉得这样拍的照片更有价值。 Ada 给你发了 Q 条求救， 那么聪明的你， 请你帮她找找距离她最远的城市， 并告诉她有多少个这样的城市。\n\n思路根据题意， 我们可以知道， 题目让我们通过最短路求出距离主人公最远的城市以及它们的数量。\n 注意！ 本题是双向边， 而且是通过求最短路找最远的城市， 而不是求最长路。\n 那么， 说到最短路， 会想到什么？\n Floyed， 时间复杂度为 O(N ^ 3)， 但是， 再看看数据， 嗯， 过不了， 会超时。\n 于是， 我们就可以写 dijkstra 再加一点优先队列优化。\n 首先， 我们要知道什么是 dijkstra 算法。 \n dijkstra 算法是用来计算一个点到其它所有点的最短路径的算法， 是一种单源最短路径算法。 \n 也就是说， 只能计算起点只有一个的情况。       \n dijkstra 算法的时间复杂度是 O(N ^ 2)， 它不能处理一些存在负边权的情况。                \n 算法描述：   \n 设起点为 s， dis_v 表示从 s 到 v 的最短路径， w[u][v] 表示有一条从 u 到 v 长度为 w 的路。\n\n初始化： dis_v = ∞, dis_s = 0               \nfor (int i = 1; i &lt;= n; ++ i) \n在没有被访问过的点中找到一个点 u 使得 dis[u] 是最小的。\n将 u 标记为已经访问过。\nfor 循环对于每一个与 u 相连的未确定的点 v。\n\n if (dis[v] &gt; dis[u] + w[u][v]) &#123;\n&#x2F;&#x2F; 找到了更短的路径\n\tdis[v] &#x3D; dis[u] + w[u][v];\n&#125;\n\n算法结束： dis[v] 为 s 到 v 的最短路径距离。\n\n 既然你已经懂得 dijkstra 算法了， 那么就先去试试这两题吧：       \n\n单源最短路径\n邮递员送信\n\n 但是， 我们再看看本题的数据：              \n 1 &lt;= N &lt; 10 ^ 5 , 0 &lt;= M &lt;= 10 ^ 6。           \n 嗯， 普通的 dijkstra 肯定会超时 ， 所以， 我们就需要优先队列优化一下。 \n 但是， 这题目翻译有坑， 题中写的是 1 &lt;= N &lt; 10 ^ 5， 但如果你只开 10 ^ 5, 那么空间是不够的。\n 所以， 我们最好开大一点。\n 所以， 堆优化过的 dijkstra 算法就是如下代码 （ 时间复杂度为 O(m log m)， 要用邻接表储存边 ）：  \n\n邻接表储存  inline void add (int x, int y, int w) &#123;\nf[++tot].y = y;\nf[tot].edge = w;\nf[tot].next = head[x];\nhead[x] = tot;\nreturn;\n  &#125;\ndijkstra 优先队列优化版  inline void dijkstra (int start_point) &#123;   \n// dijkstra 优先队列优化版\n\tfor (int i = 0; i &lt; n; i++) &#123;\n\t\tdis[i] = Inf;\n\t\tv[i] = 0;\n\t&#125;   // 初始化\n\tdis[start_point] = 0;    // 起点标记为 0 \n\tq.push (make_pair (0, start_point));  // 入队\n\twhile (!q.empty ()) &#123;     // 如果队列不为空\n\t\tint minn = q.top ().second;   // 取出所有的点中最小的一个\n\t\tq.pop ();   // 取出\n\t\tif (v[minn]) continue;  // 如果该点被访问过， 则跳过\n\t\tv[minn] = 1;   // 标记该点已访问过\n\t\tfor (int i = head[minn]; i; i = f[i].next) &#123;\n\t\t\tint y = f[i].y;\n\t\t\tint z = f[i].edge;\n\t\t\tif (dis[y] > dis[minn] + z)&#123;  // 更新最短路\n\t\t\t  dis[y] = dis[minn] + z;\n\t\t\t  q.push (make_pair (-dis[y], y));   // 下一个点入队\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\treturn;\n&#125;\n\n 接着， 我们在每一次讯问都跑一遍以输入的 s 为起点的 dijkstra ， 最后再找到最远的城市和它们的数量就行了。\n 那么， 怎么找最远的呢？\n 首先， 我们可以定义 waylongest = -1, numcity = 1。\n 接着， 我们用一个 for 循环， 其主要内容为：           \n\n如果 dis_i = maxn， 则跳过。\n如果记录的 waylongest 小于 dis_i， 则把 waylongest = dis_i。\n如果记录的 waylongest 等于 dis_i， 则把 numcity++。\n否则， 不做如何处理。\n\n 所以， 该部分代码为：       \n int way_longest = -1, num_city = 1;    \n     /*\n      way_longest : 最远的距离\n      num_city    : 距离最远的城市的个数\n      */\nfor (int i = 0; i &lt; n; ++ i) &#123;   // 找\n\tif (dis[i] == Inf) continue;  \n          // 没有通往此点的最短路径， 则跳过\n\telse if (dis[i] > way_longest) &#123;   \n          // 有更远的城市\n\t\tway_longest = dis[i];    // 更新最远距离\n\t\tnum_city = 1;   // 个数重新设为 1\n\t&#125;\n\telse if (dis[i] == way_longest) &#123;\n          // 最短路径长度与最远距离相等， 则城市个数加 1\n\t\t++ num_city;\n    &#125;\t\n&#125;\n  cout &lt;&lt; way_longest &lt;&lt; ' ' &lt;&lt; num_city &lt;&lt; '\\n';   // 输出\n 最后再把结果输出就行了。\n\n\n\n代码实现#include &lt;bits/stdc++.h>  // 万能头\n#define int long long\n#define N 10000001        // 数组大小\n#define Inf (1 &lt;&lt; 31) - 1     // 用来给 dis 初始化\nusing namespace std;\npriority_queue &lt; pair &lt;int, int> > q;     // 优先队列\nint n, m, qt;    \n/*\n n  :  城市的数量\n m  :  道路的数量\n qt :  询问的次数\n*/\nint dis[N], v[N]; \n/*\n dis : 用来记录最短路径\n  v  : 用来标记该点是否走过\n*/\nint tot, head[N]; \nstruct node &#123;\n\tint y, next, edge;\n&#125; f[N];\n/*\n 邻接表（上）\n 储  存（下）\n*/\ninline void add (int x, int y, int w) &#123;\n\tf[++tot].y = y;\n\tf[tot].edge = w;\n\tf[tot].next = head[x];\n\thead[x] = tot;\n\treturn;\n&#125;\ninline void dijkstra (int start_point) &#123;   \n// dijkstra 优先队列优化版\n\tfor (int i = 0; i &lt; n; i++) &#123;\n\t\tdis[i] = Inf;\n\t\tv[i] = 0;\n\t&#125;   // 初始化\n\tdis[start_point] = 0;    // 起点标记为 0 \n\tq.push (make_pair (0, start_point));  // 入队\n\twhile (!q.empty ()) &#123;     // 如果队列不为空\n\t\tint minn = q.top ().second;   // 取出所有的点中最小的一个\n\t\tq.pop ();   // 取出\n\t\tif (v[minn]) continue;  // 如果该点被访问过， 则跳过\n\t\tv[minn] = 1;   // 标记该点已访问过\n\t\tfor (int i = head[minn]; i; i = f[i].next) &#123;\n\t\t\tint y = f[i].y;\n\t\t\tint z = f[i].edge;\n\t\t\tif (dis[y] > dis[minn] + z)&#123;  // 更新最短路\n\t\t\t  dis[y] = dis[minn] + z;\n\t\t\t  q.push (make_pair (-dis[y], y));   // 下一个点入队\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\treturn;\n&#125;\nsigned main () &#123;\n//\tfreopen (\"SP30669.out\", \"w\", stdout);\n\tcin >> n >> m >> qt;    // 输入\n\tfor (int i = 0; i &lt; m; ++ i) &#123;  // 建图\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\tadd (u, v, w);\n\t\tadd (v, u, w);\n        // 双向边\n\t&#125;\n\tfor (int t = 0; t &lt; qt; ++ t) &#123;   // qt 次询问\n\t\tint start_point;      // 起点\n\t\tcin >> start_point;\n\t\tdijkstra (start_point);      // 跑一遍 dijkstra\n\t\tint way_longest = -1, num_city = 1;    \n        /*\n         way_longest : 最远的距离\n         num_city    : 距离最远的城市的个数\n        */\n\t\tfor (int i = 0; i &lt; n; ++ i) &#123;  \n\t\t\tif (dis[i] == Inf) continue;  \n            // 没有通往此点的最短路径， 则跳过\n\t\t\telse if (dis[i] > way_longest) &#123;   \n            // 有更远的城市\n\t\t\t\tway_longest = dis[i];    // 更新最远距离\n\t\t\t\tnum_city = 1;   // 个数重新设为 1\n\t\t\t&#125;\n\t\t\telse if (dis[i] == way_longest) &#123;\n            // 最短路径长度与最远距离相等， 则城市个数加 1\n\t\t\t\t++ num_city;\n\t\t\t&#125;\t\n\t\t&#125;\n\t\tcout &lt;&lt; way_longest &lt;&lt; ' ' &lt;&lt; num_city &lt;&lt; '\\n';   // 输出\n\t&#125;\n\treturn 0;    // 完美结束\n&#125;\n此题解仅供参考, 谢谢!\n\n","slug":"SP30669题解","date":"2023-03-19T08:55:21.000Z","categories_index":"Problem-Explanation","tags_index":"SPOJ","author_index":"Scorpio"},{"id":"2c236756dec82651c6e8b2a340fb3146","title":"UVA13197题解","content":"\n题目链接\n\n题目大意有两个非负整数 a 和 p, 需要我们求出所有的非负整数 x 使得满足 x ^ 3 mod p = a 且 x &lt; p.\n\n思路看完题目， 很容易想到， 直接枚举！因为 x &lt; p, 所以 x 最大只能是 p - 1, 再因为 x 是非负数， 所以 x 最小是 0, 那么我们就可以用一个循环把 x 从 0 到 p - 1 全部枚举一遍， 接着再判断 x ^ 3 mod p 是否等于 a 就行了！\n\n注意        \n\n本题多测       \n每一组数据的结尾不能有空格   \n升序输出  \n\n既然不能有空格， 那要怎么办呢？   其实不难， 我们只需要用一个 flag 记录该答案是否是第一个答案：  \n\n如果是， 则直接输出 x 就可以；     \n如果不是， 则在输出前还要在输出一个空格；\n\n\n代码实现\n#include &lt;bits/stdc++.h>\n#define int long long\nusing namespace std;\nint a, p, x, flag;\ninline bool check(int num) &#123;    // 判断 x^3 mod p 是否等于 a \n\treturn x * x * x % p == a ? true : false;\n&#125;\nsigned main() &#123;\n\twhile (cin >> a >> p) &#123;    // 多测 \n\t\tx = flag = 0;      // 预处理 \n\t\tfor (x = 0; x &lt; p; ++ x) &#123;    \n\t\t\t// 枚举 x, 从 0 到 p - 1 \n\t\t\tif (check(x)) &#123;    // 满足条件， 是答案 \n\t\t\t\tif (!flag) &#123;     // 该答案是第一个答案 \n\t\t\t\t\t++ flag;       // 修改 flag \n\t\t\t\t\tcout &lt;&lt; x;\t   // 直接输出 x \n\t\t\t\t&#125;\n\t\t\t\telse cout &lt;&lt; ' ' &lt;&lt; x; \n\t\t\t\t// 不是第一个答案， 还要在 x 前面在输出一个空格 \n\t\t\t&#125;\n\t\t&#125;\n\t\tcout &lt;&lt; '\\n';    // 记得每一组数据要换行 \n\t&#125;\n\treturn 0;\t         // 完美散花 \n&#125;\n此题解仅供参考, 谢谢!\n\n","slug":"UVA13197题解","date":"2023-03-19T08:53:19.000Z","categories_index":"Problem-Explanation","tags_index":"UVA","author_index":"Scorpio"},{"id":"fd1651d40ba3852722ca5b0826aced41","title":"UVA10189题解","content":"\n题目链接\n\n题目大意给你一个字符矩阵， 也就是地雷分布图， 让你求出每个不是地雷的点的周围有多少颗地雷。 有多组数据。\n\n思路 根据题目描述， 我们可以知道， 这题就是一个普通的模拟题， 只需要先遍历这个地雷分布图， 如果是 *， 就直接输出 *， 否则就遍历它周围的八个方向是否有地雷， 如果有， 那么计数器就加一， 接着在遍历完八个方向后输出地雷个数。 最后， 在每组数据之前再加一个换行就行了， 但是要注意， 每组数据之间的换行在第一组数据之前不用的， 在最后一个数据的后面也不用。\n 现在， 我们一步一来。\n\n首先我们先输入 n 和 m， 如果读入到两个都是 0 时结束。 接着， 在输入整个地雷分布图。该部分代码：while (cin >> n >> m) &#123;  // 输入\n      if (n == 0 &amp;&amp; m == 0) return 0;  // 结束\n      for (int i = 1; i &lt;= n; ++ i) \n            for (int j = 1; j &lt;= m; ++ j) \n                  cin >> mp[i][j];   // 输入地雷分布图\n&#125;\n定义一个记录数据的变量并初始化 tot = 0， 当 tot &gt; 0 时， 先输出换行， 该部分指的是每组数据与数据之间换行。该部分代码：if (tot) cout &lt;&lt; '\\n';  // 数据之间的换行\n接着输出 Field #x:， 其中 x 表示 ++ tot， 表示第 x 组数据。该部分代码：cout &lt;&lt; \"Field #\" &lt;&lt; ++ tot &lt;&lt; \":\\n\";  // 数据的个数\n然后再遍历整个地雷分布图， 如果是地雷， 直接输出 *， 否则， 遍历周围的八个方向， 如果是地雷， 计数器加一， 接着遍历完八个方向后输出个数就行了。该部分代码：int n, m, tot;\nint dx[8] = &#123;1, 1, 1, 0, -1, -1, -1, 0&#125;;\nint dy[8] = &#123;-1, 0, 1, 1, 1, 0, -1, -1&#125;;  \n// 八个方向\ninline int dfs (int x, int y) &#123;   \n// 遍历八个方向\n      int num = 0;\n      for (int i = 0; i &lt; 8; ++ i) &#123;\n            int mx = x + dx[i], my = y + dy[i];\n            if (mx &lt; 1 || my &lt; 1 || mx > n || my > m) continue;\n            else if (mp[mx][my] == '*') ++ num;  \n            // 如果是地雷， 计数器加一\n      &#125;\n      return num;\n&#125; \nfor (int i = 1; i &lt;= n; ++ i) &#123;\n      for (int j = 1; j &lt;= m; ++ j) &#123;\n          if (mp[i][j] == '*') cout &lt;&lt; mp[i][j];\n          else cout &lt;&lt; dfs (i, j);\n      &#125;\n      cout &lt;&lt; '\\n';\n  &#125;   \n  // 遍历地雷分布图\n最后， 再把每个部分的代码结合在一起就行了。  \n\n\n代码\n#include &lt;bits/stdc++.h>\n#define int long long\n#define N 101\nusing namespace std;\nchar mp[N][N];\nint n, m, tot;\nint dx[8] = &#123;1, 1, 1, 0, -1, -1, -1, 0&#125;;\nint dy[8] = &#123;-1, 0, 1, 1, 1, 0, -1, -1&#125;;  \n// 八个方向\ninline int dfs (int x, int y) &#123;   \n// 遍历八个方向\n    int num = 0;\n    for (int i = 0; i &lt; 8; ++ i) &#123;\n        int mx = x + dx[i], my = y + dy[i];\n        if (mx &lt; 1 || my &lt; 1 || mx > n || my > m) continue;\n        else if (mp[mx][my] == '*') ++ num;  \n        // 如果是地雷， 计数器加一\n    &#125;\n    return num;\n&#125; \nsigned main () &#123;\n    while (cin >> n >> m) &#123;  \n    // 输入\n        if (n == 0 &amp;&amp; m == 0) return 0;  \n        // 结束\n        for (int i = 1; i &lt;= n; ++ i) \n            for (int j = 1; j &lt;= m; ++ j) \n                cin >> mp[i][j];   \n                // 输入地雷分布图\n\n        if (tot) cout &lt;&lt; '\\n';  \n        // 数据之间的换行\n        cout &lt;&lt; \"Field #\" &lt;&lt; ++ tot &lt;&lt; \":\\n\"; \n        // 数据的个数\n        for (int i = 1; i &lt;= n; ++ i) &#123;\n            for (int j = 1; j &lt;= m; ++ j) &#123;\n                if (mp[i][j] == '*') cout &lt;&lt; mp[i][j];\n                else cout &lt;&lt; dfs (i, j);\n            &#125;\n            cout &lt;&lt; '\\n';\n        &#125;   \n        // 遍历地雷分布图\n    &#125;\n    return 0;  \n    // 完美结束\n&#125;\n此题解仅供参考, 谢谢!\n\n","slug":"UVA10189题解","date":"2023-03-19T08:47:25.000Z","categories_index":"Problem-Explanation","tags_index":"UVA","author_index":"Scorpio"},{"id":"11d1cc0f8fe89d28a1b1aece459d33f1","title":"CF472B题解","content":"\n题目链接\n\n题目大意有 n 个人， 每个人都有自己想要到达的楼层， 第 i 想要去第 fi 层。 同时有一个电梯， 电梯的最大承受人数为 k。 求电梯的最小运行层数。\n\n思路要求电梯的最小运行层数， 我们就要先知道单次电梯的运行层数怎么求。\n假设电梯里有 m 个人, 其中第 i 个人的希望到达层数为 fi, 那么该次电梯的运行数为所有人的希望到达层数的最大值， 即 max{f1, f2…f{m - 1}, fm}\n其次， 因为单次电梯的运行层数为电梯里所有人的希望到达层数的最大值。 所以， 我们可以尽可能地把希望到达层数较大的人放在一起， 同时乘坐电梯， 同时尽可能地将电梯装满。\n接着， 由于电梯从 1 楼上去后还要回到 1 楼。 所以， 在计算电梯单次运行层数时要乘 2. 同时， 电梯从第 1 楼到 t 层共走了 t - 1 层。 所以， 单次电梯的运行层数为 2 * (fi - 1).\n最后， 因为要尽可能地将希望到达层数较大的人放在一起， 所以我们可以先把所有人的希望到达层数从大到小排序一下就可以了。\n\n代码实现\n#include &lt;bits/stdc++.h>\n  #define int long long\n  #define N 1000000\n  using namespace std;\n  inline int read() &#123;   // 快读 \n      int f = 0, n = 1;\n      char ch = getchar();\n      while (!isdigit(ch)) &#123;\n          if (ch == '-') n *= -1;\n          ch = getchar();\t\n      &#125;\n      while (isdigit(ch)) &#123;\n          f = (f &lt;&lt; 1) + (f &lt;&lt; 3) + ch - '0';\n          ch = getchar();\n      &#125;\n      return f * n;\t\n  &#125;\n  int cmp(int x, int y) &#123;   // sort排序用的  \n      return x > y;\t // 从大到小排序 \n  &#125;\n  int n, k, tot, f[N];\n  /*\n   n   : 人数\n   k   : 电梯的最大承受人数\n   tot : 最终结果， 即电梯的最小运行层数\n   f[] : 用来储存所有人希望到达的楼层 \n  */\n  signed main() &#123;  // 主函数 \n      n = read(), k = read();\n      for (int i = 1; i &lt;= n; ++ i) f[i] = read();\n      // 输入， 具体见上注释 \n      sort (f + 1, f + n + 1, cmp);\n      // 排序， 使所有人希望到达的楼层数按从大到小的顺序 \n      for (int i = 1; i &lt;= n; i += k) &#123;\n          // 每次装满电梯， 所以 i += k \n          tot += 2 * (f[i] - 1);\t\n          /*\n              因为电梯上去后还要回到第 1 层, 所以要乘 2 \n              从第 1 层到第 i 层共走了 (i - 1) 层\n              单次电梯运行数为电梯里最大的希望到达数 \n          */\n      &#125;\n      printf (\"%d\\n\", tot);\n      // 输出最终结果 \n      return 0;\t  // 完美结束 \n  &#125; \n此题解仅供参考, 谢谢!\n\n","slug":"CF472B题解","date":"2023-03-19T08:42:27.000Z","categories_index":"Problem-Explanation","tags_index":"Codeforces","author_index":"Scorpio"},{"id":"84cd9d22260caf953fbe318a70e7da7c","title":"CF1784A题解","content":"\n题目链接\n\n题目大意有一个序列 a1, a2 … a{n-1}, a{n} 且所有元素皆为正整数，共有两种操作，使得进行若干次操作后的序列的所有元素皆不大于零，求第一种操作的最小操作次数。\n操作如下：   \n\n选择序列中的任意一个正整数元素，将其减一；\n将序列中所有的正整数元素都将其减一，如有元素因此操作小于等于零，则再次进行一次此操作；\n\n\n注意第一种操作可以执行无数次，第二种操作只可以执行一次。\n\n思路很明显，如果序列中的所有元素皆满足 ai + 1 = a{i + 1} 的话，那么我们只需要进行一次操作二即可将序列清零。\n所以，我们便可以先使用操作一将序列有序化（如上），然后在进行一次操作二即可。\n但是，为了最小化第一种操作，为了避免不需要的操作，我们先将序列排序一遍.\n\n代码实现\n#include &lt;bits/stdc++.h>\n#define int long long\nnamespace S_T_D &#123;\n\tinline int Read() &#123;\n\t\tint f = 0, n = 1;\n\t\tchar ch = getchar();\n\t\twhile (!isdigit(ch)) &#123;\n\t\t\tif (ch == '-') n *= -1;\n\t\t\tch = getchar();\t\n\t\t&#125;\n\t\twhile (isdigit(ch)) &#123;\n\t\t\tf = (f &lt;&lt; 1) + (f &lt;&lt; 3) + ch - '0';\n\t\t\tch = getchar();\t\n\t\t&#125;\n\t\treturn f * n;\n\t&#125;\n\tinline void write(int x) &#123;\n\t\tif (x &lt; 0) x = -x, putchar('-');\n\t\tif (x > 9) write(x / 10);\n\t\tputchar(x % 10 ^ 48);\n\t\treturn;\t\t\n\t&#125;\n\tinline int min(int x, int y) &#123;\n\t    return x &lt; y ? x : y;\n    &#125;\n    inline int max(int x, int y) &#123;\n    \treturn x > y ? x : y;\n    &#125;\n\t#define read Read()\n&#125;\nusing namespace std;\nusing namespace S_T_D;\nconst int N = 2e5 + 1;\nint T, n, tot, num, a[N];\nsigned main() &#123;\n\tT = read;              // 多组数据 \n\twhile (T --) &#123;\n\t\tn = read;\n\t\ttot = 0, num = 0;  \n\t\t/*\n\t\t\ttot : 操作一次数 \n\t\t\tnum : 序列有序化基准值\n\t\t*/ \n\t\tfor (int i = 1; i &lt;= n; ++ i) a[i] = read;\n\t\tsort(a + 1, a + n + 1);       // 先从小到大排序一遍 \n\t\tfor (int i = 1; i &lt;= n; ++ i) &#123;\n\t\t\tif (a[i] == num) continue;   // 如果等于基准值，无需操作，跳过 \n\t\t\telse ++ num, tot += a[i] - num;\t   // 否则将基准值 + 1，再进行操作一 \n\t\t&#125;\n\t\twrite(tot), puts(\"\");    // 输出答案 \n\t&#125;\n\treturn 0;\n&#125;\t\n此题解仅供参考, 谢谢!\n\n","slug":"CF1784A题解","date":"2023-03-19T08:32:12.000Z","categories_index":"Problem-Explanation","tags_index":"Codeforces","author_index":"Scorpio"},{"id":"365f8d660f31d41852d831b89da3e2a8","title":"2018年刑侦科推理试题讲解","content":"提示：本文章将讲解 《2018年刑侦科推理试题》 的解题过程\n\n首先看看题就知道这 10 道题目之间相互有线索关联着。第一轮查找线索：（找出题面话语背后的意思）第1题：找不到有用的线索，答案应该是根据其它题目确定的；第2题：说答案是第5题的答案，但是答案的排列完全不同（A.C B.D C.A D.B），所以得出线索是第2题答案 ≠ 第5题的答案；第3题：说有一题的答案与其他三道题目的答案不同，即只有一题的答案不同，线索是第2、3、4、6题中有3道题的答案相同；第4题：说选项中有一组题的答案相同，则线索是 (1,5) 、(2,7)、 (1,9)、 (6,10) 这四组中只有一组题目的答案相同；第5题：说选项 4 道题中有一题的答案与本题的答案相同， 线索是第4、8、7、9 题中有一题的答案 = 第5题的答案，其它均 ≠ 第5题的答案；第6题：说仅有两题与第8题相同，线索是第(2,4) 、(1,6) 、(3,10)、 (5,9) 题中有一组等于第8题，其它与第8题不同；第7题：选中次数最少，次数需要统计，应该是最后才知道结果的，现在先不考虑它；第8题：与第一题的答案字母不相邻，线索是第 2、5、7、10 题中有3题答案与第1题答案字母相邻；第9题：两条逻辑语句真假性相反，线索是第9题两句中有一句肯定是真的，另一句肯定是假的；第10题：出现次数差，也需要统计，应该也是最后才知道结果，前面也先不考虑它。经过一轮的简单分析后，我们得到如下线索：线索1：第2题和第5题答案不相同；线索2：第2、3、4、6 题中有3个答案相同；线索3：(1,5)、 (2,7) 、(1,9)、 (6,10) 这四组中有一组答案相同；线索4：第4、7、8、9 题中有一题和第5题答案相同，其它与第5题不同；线索5：第 (2,4)、 (1,6) 、(3,10) 、(5,9) 题中有一组和第8题答案相同，其它与第8题不同；线索6：第2、5、7、10 题中有3题答案与第1题答案字母相连；线索7：第9题两句中有一句肯定是真的，另一句肯定是假的；经过整理， 我们发现第7条线索给出的是一个逻辑判断的条件，那么一真一假之间，只需要最多验证两次假设即可，所以我们选择从第7条线索展开思考。分析线索7：“第1题与第6题的答案相同” 与 “第X题与第5题的答案相同” 两句话的真假性相反，也就是说这两句话“一真一假”。先假设“第1题与第6题的答案相同”是真的。那么我们需要找出满足“第X题与第5题的答案相同”这句话是假的证据，也就是第X题和第5题答案不相同。因为是单选题的原因，选项中应该只存在一个答案不相同，其它三个答案应该都与第5题相同。根据上面线索1判断，只有第2题答案不等于第5题，那么其它第1、6、9、10 题都是和第5题答案相同。这时我们发现这个结果违背了线索3，线索3中应该只有一组答案相同，但是(1,9) 、(6,10) 都是相同的。那么最后结论是“第1题与第6题的答案相同”的假设不成立，而“第X题与第5题的答案相同”是成立的。这里X肯定不是C，因为线索1中确定了第2题和第5题答案不相同。这里X肯定也不是D，因为第9题若是和第5题相同，则第5题答案是C，很明显D也是错的。增加线索：线索8：第1题和第6题答案不相同；线索9：第9题和第5题答案不相同；继续分析：这里X肯定也不是A，因为假设是A则第5题和第6题答案相同，就可以推论：第5题和第6题答案都是A时：结果为第2、4、5、8题答案都相同，显示违背了线索1，不成立；第5题和第6题答案都是B时：第6题的选项B已经违背了线索8，不成立；第5题和第6题答案都是C时：第5题选择C就已经违背了线索9，不成立；第5题和第6题答案都是D时：第6题的选项D已经违背了线索9，不成立；所以X的结果是B.第10题。增加线索：线索10：第5题和第10题答案相同；第9题分析完成，我们得出了第1个确定的答案：第9题答案：B；再来分析第6题：（选择第6题的原因是它给出的条件最多，越多的条件越容易找出反例）第6题选A，则第2，4题和第8题答案相同是不成立的，证明如下：第2、4、8题答案都选A时：\n第2题选A：第5题的答案是C，第5题和第9题答案相同，这样违背了线索9，不成立；\n\n第2、4、8题答案都选B时：\n第2题选B：第5题的答案是D，第5题和第7题答案相同，这样第7题答案也是D；\n\n第4题选B：第2题和第7题答案相同，但当前第2题答案是B，显示也不成立；\n\n\n第2、4、8题答案都选C时：\n第4题选C：第1题和第9题答案相同，第1题答案就是B；\n\n第8题选C：第2题和第1题答案不相邻，但现在第1题答案是B，第2题选择是C，相邻了不成立；\n\n\n第2、4、8题答案都选D时：\n第2题选D：第5题答案是B，第4题答案就和第5题相同也是B，可是当前第4题选择是D，不成立；\n\n第6题选B，直接违背线索8，不成立。第6题选D，直接违背线索9，不成立。第9题分析完成，我们得出了第2个确定的答案：第6题答案：C可以修改线索：线索11：第5，10，3，8题答案相同；接下来可以直接得出其它答案了：第5题答案：A，通过第5题的题目与线索10判断；第3题答案：A，通过线索10判断；第8题答案：A，通过线索10判断；第10题答案：A，通过线索10判断；第2题答案：C，通过第5题答案判断；第7题答案：D，通过已有7个答案和第4题判断：\n目前A答案有4个，B答案有1个，C答案有2个，D答案有0个；\n\n第4题答案不可能是D，因为第6题答案和第10题答案不同；\n\n第4题答案不可能是B，若第7题答案是C，而A答案结果不可能成为最少的；\n\n第4题答案不可能是A，因为A答案有5个，这样无法同时满足第7题和第10题的描述；\n\n\n第4题答案：C，通过上面分析得出；第1题答案：B，通过第4题答案和第9题答案得出；所以， 最终答案为1.B, 2.C, 3.A, 4.C, 5.A, 6.C, 7.D, 8.A, 9.B, 10.A此文章仅供参考，如有疑问，请发送邮件至 2966653003@qq.com， 谢谢!","slug":"2018年刑侦科推理试题讲解","date":"2023-01-26T06:38:13.000Z","categories_index":"学术","tags_index":"讲解,逻辑推理,刑侦科,2018年刑侦科推理试题","author_index":"Scorpio"},{"id":"9b767e0c0dbe490fefea07749303c21c","title":"物理“声的传播”例题分享","content":"提示：本文章将要讲的是初中物理中有关“声的传播”的基本例题分享【例 1】如图 1.1 所示， 声源 S 和观察者 A 都沿 x 轴正方向运动， 相对与地面的速率分别为 Vs 和 Va， 空气中声音的传播速率为 Vp， 设 Vs &lt; Vp， Va &lt; Vp， 空气相对于地面没有流动。\n\n（1） 若声源相继发出两个声信号，时间间隔为 Δt， 请根据发出的这两个声信号从声源传播到观察者的过程， 确定观察者接收到这两个声信号的时间间隔 Δt’。【解析】（1）设 t1， t2 为声源 S 发出的两个信号的时刻， t1’， t2’ 为观察者接收到两个信号的时刻。 则第一个信号经过 t1’ - t1 时间被观察者 A 接收到， 第二个信号经过 t2’ - t2 时间被观察者 A 接收到， 且 t2 - t1 = Δt， t2’ - t1’ = Δt’。 设声源发出的第一个信号时， S 和 A 间的距离为 L， 两个声信号从声源传播到观察者的过程中， 它们的远动的距离关系如图 1.2 和 1.3 所示。\n\n\n\n于是， 可得：1. Vp(t1’ - t1) = L + Va(t1’ - t1)2. Vp(t2’ - t2) = L + Va(t2’ - t1) - VsΔt由以上两式解得：Δt’ = (Vp - Vs)Δt / (Vp - Va)此文章仅供参考，如有疑问，请发送邮件至 2966653003@qq.com， 谢谢!","slug":"物理例题分享[1]","date":"2022-12-04T08:11:05.000Z","categories_index":"学术","tags_index":"物理,学习笔记","author_index":"Scorpio"},{"id":"b8278ec2c4d426b09bc57c8661224203","title":"CF1730A题解","content":"Codeforces Round #823 (Div. 2) A.Plantes 题解原题链接题目大意题意大致是: 在 n 条轨道里, 每一条轨道上都有一些星球(即障碍物), 且第 i 条轨道上共有 a[i] 个障碍物.现在有两台可以消灭障碍物的机器 A 和 B.机器 A 一次性只能消灭一个障碍物, 而且每消灭一个障碍物, 总费用就要加 1.机器 B 一次性只能消灭一条轨道上的所有消灭障碍物, 而且每消灭一条轨道的所有障碍物, 总费用就要加上一个固定的数 k.求消灭掉所有的障碍物的最小费用?具体思路根据题目意思, 我们可以发现, 消灭任何一条轨道上的障碍物的方法大致分为两种(没列出来的表示不重要):1. 用机器 A 消灭, 费用为 a[i], 记为 A[i].2. 用机器 B 消灭, 费用为 k, 记为 B[i].所以, 我们在每一条轨道上的最小费用就是 min(A[i], B[i])所以, 我们只需要把每一条轨道上的最小费用加在一起, 就是总费用了.代码实现#include &lt;bits/stdc++.h>\n#define int long long\n#define N 110\nusing namespace std;\ninline int read() &#123;\n\tint f = 0, n = 1;\n\tchar ch = getchar();\n\twhile (!isdigit(ch)) &#123;\n\t\tif (ch == '-') n *= -1;\n\t\tch = getchar();\t\n\t&#125;\n\twhile (isdigit(ch)) &#123;\n\t\tf = (f &lt;&lt; 1) + (f &lt;&lt; 3)\t+ ch - '0';\n\t\tch = getchar();\n\t&#125;\n\treturn f * n;\t\n&#125;\nint T = read();\nsigned main() &#123;\n\twhile (T --) &#123;\n\t\tint tot = 0, n = read(), k = read(), a[N], h[N] = &#123;0&#125;;\n\t\tfor (int i = 1; i &lt;= n; ++ i) a[i] = read(), h[a[i]] ++;\n\t\tfor (int i = 1; i &lt;= 100; ++ i) &#123;\n\t\t\tif (!h[i]) continue;\n\t\t\ttot += min(k, h[i]);\n\t\t&#125;\n\t\tcout &lt;&lt; tot &lt;&lt; '\\n';\n\t&#125;\n\treturn 0;\t\n&#125;\n此题解仅供参考, 若有疑问请在评论区留言, 谢谢!","slug":"Codeforces-Round823(Div. 2)[A.Planets]","date":"2022-09-30T10:23:17.000Z","categories_index":"Problem-Explanation","tags_index":"Codeforces","author_index":"Scorpio"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"「人生若只如初见，何事秋风悲画扇」大家好！我是 Scorpio_Limit，相遇即是缘分，感谢您能在百忙之中浏览这个网页，作为一个普普通通的 OIer，我将在次博客中分享学科知识、题目解题思路题解、生活日常、和一些有趣的东西。若对本博客有疑问、建议等问题， 请通过邮箱 2966653003@qq.com 向作者反馈， 谢谢配合！","slug":"hello","date":"2022-08-30T01:58:32.000Z","categories_index":"Hello","tags_index":"Welcome","author_index":"Scorpio"}]